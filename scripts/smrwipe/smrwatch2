#!/usr/bin/env bash
#
# smrwatch - live SMR wipe monitoring TUI with progress bars
# Author: Mike Wilson <mike@mikewilsonstl.com>
# Created: 2025-12-15
# Usage: ./smrwatch
# Author: Mike Wilson <mike@mikewilsonstl.com>
# Created: 2025-12-22T14:07:52-05:00
# Description: Watches the active smrwipe processes and monitors IO
#              pressure. If this gets too high, wipes will fail.
#
# TODO: Add logging export at the end of the process. Calculate average values.
#       Consider adding basic analytics at the end of the program. Add information
#       to the display so the user understands what the numbers mean.(Are these 
#       numbers percentages? what is the unit? what is the limit? Am I close? 
#       Do I have the bandwidth to add another worker to the next wipe?)

set -euo pipefail
shopt -s nullglob

RUN_ID=$(date +%Y%m%d-%H%M%S)
LOG_DIR=${TMPDIR:-/tmp}/smrwatch-$RUN_ID
mkdir -p "$LOG_DIR"
SAMPLE_LOG="$LOG_DIR/samples.log"
EVENT_LOG="$LOG_DIR/events.log"
DD_LOG="$LOG_DIR/dd.log"

INTERVAL=1

# ANSI colors
RED="\033[1;31m"
YELLOW="\033[1;33m"
GREEN="\033[1;32m"
CYAN="\033[1;36m"
# BLUE="\033[1;34m"
RESET="\033[0m"

hide_cursor() { printf "\033[?25l"; }
show_cursor() { printf "\033[?25h"; }

cleanup() {
    show_cursor
    printf "\033[0m\n"
    generate_report
}

trap cleanup EXIT INT TERM

die() {
    echo "ERROR: $*" >&2
    exit 1
}

require_cgroup_v2() {
    [[ -f /sys/fs/cgroup/cgroup.controllers ]] || die "cgroup v2 not mounted"
    grep -qw io /sys/fs/cgroup/cgroup.controllers || die "IO controller not available"
}

resolve_cgroup() {
    PID=$(pgrep -n -f 'python3 main.py')
    [[ -n "$PID" ]] || die "smrwipe not running"

    SCOPE=$(grep smrwipe.scope /proc/"$PID"/cgroup | cut -d: -f3)
    [[ -n "$SCOPE" ]] || die "Unable to determine cgroup path"

    CG=/sys/fs/cgroup${SCOPE}
    [[ -d "$CG" ]] || die "cgroup path not found: $CG"

    echo "$CG"
}

get_worker_dd_pids() {
    local worker_cg=$1
    sed -n 's/^0:://p' "$worker_cg/cgroup.procs" \
        | xargs -r -n1 ps -o pid=,comm= \
        | awk '$2=="dd"{print $1}'
}

collect_dd_metrics() {
    local worker=$1
    local cg=$2
    local ts
    ts=$(date +%s)

    for pid in $(get_worker_dd_pids "$cg"); do
        [[ -r /proc/$pid/io ]] || continue

        bytes=$(awk '/write_bytes/ {print $2}' /proc/$pid/io)
        syscr=$(awk '/syscw/ {print $2}' /proc/$pid/io)

        echo "$ts|$worker|$pid|$bytes|$syscr" >> "$DD_LOG"
    done
}

color_value() {
    local val=$1 type=$2
    if [[ -z "$val" ]]; then
        echo -e "$RESET$val"
    elif (( $(echo "$val > 0.0" | bc -l) )); then
        if [[ "$type" == "full" ]]; then
            echo -e "${RED}$val${RESET}"
        else
            echo -e "${YELLOW}$val${RESET}"
        fi
    else
        echo -e "${GREEN}$val${RESET}"
    fi
}

draw_progress_bar() {
    local percent=$1 width=${2:-20}
    local filled=$(( percent * width / 100 ))
    local empty=$(( width - filled ))
    printf "["
    printf "%0.s#" $(seq 1 $filled)
    printf "%0.s-" $(seq 1 $empty)
    printf "] %3d%%" "$percent"
}

print_scope_pressure() {
#   local cg=$1
#   echo -e "${CYAN}== Scope IO Pressure ==${RESET}"

#   if [[ -f "$cg/io.pressure" ]]; then
#       while read -r line; do
#           some=$(echo "$line" | awk '{print $1}' | cut -d= -f2)
#           full=$(echo "$line" | awk '{print $2}' | cut -d= -f2)
#           printf " some: %s full: %s\n" \
#               "$(color_value "$some" some)" \
#               "$(color_value "$full" full)"
#       done < "$cg/io.pressure"
#   else
#       echo "(no io.pressure yet)"
#   fi
#   echo
    echo -e "${CYAN}== Scope IO Pressure ==${RESET}"
    local cg=$1
    local some=0 full=0

    [[ -f "$cg/io.pressure" ]] || { echo "0 0"; return; }

    read -r _ some_line full_line < <(sed -n '1,2p' "$cg/io.pressure")

    some=$(awk -F= '{print $2}' <<<"$some_line")
    full=$(awk -F= '{print $2}' <<<"$full_line")

    echo "$some $full"
}

sample_workers() {
    local cg=$1
    local ts
    ts=$(date +%s)

    read io_some io_full < <(read_scope_pressure "$cg")

    for d in "$cg"/worker-*; do
        [[ -d "$d" ]] || continue

        worker=$(basename "$d")

        verify=0
        [[ -f "$d/io.stat" ]] && verify=$(grep -oP 'verify_percent=\K[0-9.]+' "$d/io.stat" || echo 0)
        verify=${verify%.*}

        status="UNKNOWN"
        [[ -f "$d/status" ]] && status=$(head -n1 "$d/status")

        echo "$ts|$worker|$verify|$status|$io_some|$io_full" >> "$SAMPLE_LOG"
        collect_dd_metrics "$worker" "$d"
    done
}


print_workers() {
    local cg=$1
    if compgen -G "$cg/worker-*" > /dev/null; then
        printf "%-15s %-20s %-10s %-10s\n" "WORKER" "IO MAX" "PROGRESS" "STATUS"
        for d in "$cg"/worker-*; do
            worker=$(basename "$d")

            # io.max
            io_max="N/A"
            [[ -f "$d/io.max" ]] && io_max=$(head -n1 "$d/io.max")
            io_max=$(printf "%-18.18s" "$io_max")

            # get verify_percent from a file (Python could write to io.stat temporarily for demo)
            verify=0
            [[ -f "$d/io.stat" ]] && verify=$(grep -oP 'verify_percent=\K[0-9.]+' "$d/io.stat" || true)
            verify=${verify%.*}  # integer for progress bar

            # hash verification status (Python could write to a file in worker dir)
            status="UNKNOWN"
            [[ -f "$d/status" ]] && status=$(head -n1 "$d/status")
            case "$status" in
                PASS) status="${GREEN}PASS${RESET}" ;;
                FAIL) status="${RED}FAIL${RESET}" ;;
                *) status="${YELLOW}UNKNOWN${RESET}" ;;
            esac

            prog=$(draw_progress_bar "$verify" 20)

            printf "%-15s %-20s %-10s %-10s\n" "$worker" "$io_max" "$prog" "$status"
        done
    else
        echo "(no worker cgroups â€” running in single scope)"
    fi
    echo
}

track_events() {
    local cg=$1
    local ts
    ts=$(date +%s)

    local workers
    workers=$(ls -d "$cg"/worker-* 2>/dev/null | wc -l)

    [[ ! -f "$LOG_DIR/seen_workers" && "$workers" -gt 0 ]] && {
        echo "$ts|ENUM_DONE" >> "$EVENT_LOG"
        touch "$LOG_DIR/seen_workers"
    }

    for d in "$cg"/worker-*; do
        [[ -d "$d" ]] || continue
        worker=$(basename "$d")

        [[ ! -f "$LOG_DIR/$worker.started" ]] && {
            verify=$(grep -oP 'verify_percent=\K[0-9.]+' "$d/io.stat" 2>/dev/null || echo 0)
            (( verify > 0 )) && {
                echo "$ts|$worker|START" >> "$EVENT_LOG"
                touch "$LOG_DIR/$worker.started"
            }
        }

        [[ -f "$d/status" && ! -f "$LOG_DIR/$worker.ended" ]] && {
            status=$(head -n1 "$d/status")
            echo "$ts|$worker|END|$status" >> "$EVENT_LOG"
            touch "$LOG_DIR/$worker.ended"
        }
    done
}

track_events() {
    local cg=$1
    local ts
    ts=$(date +%s)

    local workers
    workers=$(ls -d "$cg"/worker-* 2>/dev/null | wc -l)

    [[ ! -f "$LOG_DIR/seen_workers" && "$workers" -gt 0 ]] && {
        echo "$ts|ENUM_DONE" >> "$EVENT_LOG"
        touch "$LOG_DIR/seen_workers"
    }

    for d in "$cg"/worker-*; do
        [[ -d "$d" ]] || continue
        worker=$(basename "$d")

        [[ ! -f "$LOG_DIR/$worker.started" ]] && {
            verify=$(grep -oP 'verify_percent=\K[0-9.]+' "$d/io.stat" 2>/dev/null || echo 0)
            (( verify > 0 )) && {
                echo "$ts|$worker|START" >> "$EVENT_LOG"
                touch "$LOG_DIR/$worker.started"
            }
        }

        [[ -f "$d/status" && ! -f "$LOG_DIR/$worker.ended" ]] && {
            status=$(head -n1 "$d/status")
            echo "$ts|$worker|END|$status" >> "$EVENT_LOG"
            touch "$LOG_DIR/$worker.ended"
        }
    done
}

clear_screen() {
    printf "\033[H"
}

main_loop() {
    local cg=$1
    while true; do
        clear_screen
        echo -e "${CYAN}SMR Wipe Monitoring Dashboard${RESET}"
        echo "============================="
        date
        echo

        print_scope_pressure "$cg"
        print_workers "$cg"
	sample_workers "$cg"

        sleep "$INTERVAL"
    done
}

generate_report() {
    echo
    echo "========== SMR WIPE SUMMARY =========="
    echo "Run ID: $RUN_ID"
    echo "Log dir: $LOG_DIR"
    echo

    awk -F'|' '
    {
        samples[$2]++
        if ($3 > max[$2]) max[$2]=$3
        io_some_sum += $5
        io_full_sum += $6
        total++
    }
    END {
        printf "Workers seen: %d\n", length(samples)
        printf "Average IO pressure (some): %.3f\n", io_some_sum/total
        printf "Average IO pressure (full): %.3f\n", io_full_sum/total
    }' "$SAMPLE_LOG"

    echo
    echo "-- Drive Durations --"

    awk -F'|' '
    $2=="START"{start[$1]=$1}
    $2=="END"{end[$1]=$1; status[$1]=$4}
    END {
        for (w in start) {
            if (end[w]) {
                dur=end[w]-start[w]
                printf "%s: %ds (%s)\n", w, dur, status[w]
            }
        }
    }' "$EVENT_LOG"

    echo
    echo "-- Pass / Fail Ratio --"

    awk -F'|' '
    $4=="PASS"{p++}
    $4=="FAIL"{f++}
    END {
        printf "PASS: %d  FAIL: %d\n", p, f
    }' "$EVENT_LOG"

    echo
}

main() {
    require_cgroup_v2
    CG=$(resolve_cgroup)
    echo "Monitoring cgroup: $CG"
    sleep 1
    printf "\033[2J"   # clear screen once
    hide_cursor
    main_loop "$CG"
}

main "$@"
